#a setuptools package can have options, available when doing
#pip install foo[option]
#this can be overloaded in the Makefile with (for every package)
#OPTIONAL_FEATURES:='[option]'
OPTIONAL_FEATURES?=

#see if we're in a virtualenv, and use that, otherwise use the default
ifdef VIRTUAL_ENV
	PLATFORM_VENV=$(VIRTUAL_ENV)
else
	PLATFORM_VENV=platform_venv
endif

#timeout of nosetest, per test, only active for test-nocover
#needs to be long, due to interactive w/ SLURM queue, but this has to be
#below the jenkins timeout
TIMEOUT?=530

PYTHON_PIP_VERSION?=pip>=19
SETUPTOOLS_VERSION?=setuptools>=40
DOC_REQS?=sphinx==1.1.3 sphinxcontrib-napoleon==0.2.7

python_version_full := $(wordlist 2,4,$(subst ., ,$(shell python --version 2>&1)))
python_version_major := $(word 1,${python_version_full})

PIP=$(shell readlink -f $(PLATFORM_VENV)/bin/pip)
PYTHON=$(shell readlink -f $(PLATFORM_VENV)/bin/python)
CACHE_DIR?=cache

SHELL=/bin/bash

# A literal space, yes, I love Makefiles, why do you ask?
EMPTY:=
SPACE:=$(EMPTY) $(EMPTY)
COMMA:= ,

###########################################################
######################### Help ############################
###########################################################
define HELPTEXT
platform Makefile usage
 Targets:
	devinstall      as install but in development mode to make in-place source changes
	clean           clean everything generated by make
	virtualenv      create a virtual env
	help            this help
endef

export HELPTEXT
help:
	@echo "$$HELPTEXT"
.PHONY: help


###########################################################
######################### Helpers #########################
###########################################################

#called with $(call WARN,Text to display)
#this is idempotent: it doesn't change the $?
WARN={ res=$$?; [ -n "$$TERM" ] && tput setaf 1; echo "$(1)"; [ -n "$$TERM" ] && tput sgr0; [ $$res -eq 0 ]; }

#run a command with the utils.sh in the environment
# note the trailing space
RUN_UTILS=/bin/bash --rcfile $(UTILS) -i -c

#helpful for debug
print-%:
	$(info $*)
	@echo '$*=[$($*)]'

###########################################################
######################### Install #########################
###########################################################

devinstall: virtualenv
	for f in $(INSTALL_MODULES); do \
		[ -f $$f/setup_requirements.txt ] && $(PIP) install $(PIPPROXY) -r $$f/setup_requirements.txt; \
		(cd $$f && $(PIP) install $(PIPPROXY) --pre -e .$(OPTIONAL_FEATURES)) || exit 1; \
	done

#delete everything we don't need
clean:
	rm -rf platform_venv
	for i in '*.pyc' 'pep8.txt' 'pylint.txt'; do \
		find . -name $$i -delete; \
	done

.PHONY: devinstall clean download-req

###########################################################
######################### SCHEMAS #########################
###########################################################

#$(info $$SCHEMA_GENERATION is [${SCHEMA_GENERATION}])

ifdef SCHEMA_GENERATION

schemas-build: virtualenv 
	for f in $(SCHEMA_GENERATION); do \
		IFS=':' read -r -a schema <<< "$$f"; \
		. $(PLATFORM_VENV)/bin/activate;\
		pyxbgen -u $(HBP)/"$${schema[0]}"/"$${schema[1]}" -m "$${schema[2]}" 2>&1 | grep -v "^WARNING" || { echo ERROR;exit 1; }; \
	done

schemas-install: schemas-build $(SCHEMA_TARGET_LOCATION)/__init__.py
	for f in $(SCHEMA_GENERATION); do \
		IFS=':' read -r -a schema <<< "$$f"; \
		mv "$${schema[2]}".py $(SCHEMA_TARGET_LOCATION)/ ;\
	done

schemas-clean:
	for f in $(SCHEMA_GENERATION); do \
		IFS=':' read -r -a schema <<< "$$f"; \
		rm -rf $(SCHEMA_TARGET_LOCATION)/"$${schema[2]}".py; \
	done

$(SCHEMA_TARGET_LOCATION)/__init__.py: 
	[ -z $$SCHEMA_TARGET_LOCATION ] || touch $@

devinstall-schemas: devinstall schemas-install

.PHONY: devinstall-schemas schemas-install schemas-build schemas-get schemas-dep

#...ifdef SCHEMA_GENERATION
endif  

###########################################################
######################### VirtualEnv ######################
###########################################################

virtualenv: $(PLATFORM_VENV)/bin/activate $(PLATFORM_VENV)/new-pip.txt

CHECK_PYTHON_PATH:=@[ -n "$$PYTHONPATH" ] && $(call WARN,PYTHONPATH is set: ($${PYTHONPATH}) this may cause problems with the virtualenv) || true

#create a virtualenv
$(PLATFORM_VENV)/bin/activate:
	$(CHECK_PYTHON_PATH)
	if [ $(python_version_major) -lt 3 ]; then \
		virtualenv --no-site-packages $(PLATFORM_VENV); \
	else \
		python -m venv $(PLATFORM_VENV); \
	fi
	touch $(PLATFORM_VENV)/bin/activate

#need new version of pip for our setup.py methods
$(PLATFORM_VENV)/new-pip.txt: $(PLATFORM_VENV)/bin/activate
	$(PIP) install $(PIPPROXY) --upgrade $(PYTHON_PIP_VERSION)
	$(PIP) install $(PIPPROXY) '$(SETUPTOOLS_VERSION)'
	touch $(PLATFORM_VENV)/new-pip.txt

%.req_make: %.txt
	$(CHECK_PYTHON_PATH)
	$(PIP) install $(PIPPROXY) -r $< --upgrade --pre
	touch $@

###########################################################
######################### VERSION #########################
###########################################################

# Get version from the git tagging
set-nrp-version:
	$(eval SCM_VERSION := $(shell source $(HBP)/nrp-user-scripts/nrp_get_scm_version.sh get_scm_version))
	for f in $(TEST_MODULES); do \
		echo "VERSION = '$(SCM_VERSION)'" > $$f/version.py; \
	done

.PHONY: set-nrp-version